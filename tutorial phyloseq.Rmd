---
title: "tutorial phyloseq"
output: github_document
---
#charger les library
```{r}
library(dada2)
library(phyloseq)
library(DECIPHER)
library(phangorn)
library(ggplot2)
library(gridExtra)
```
#créer une varible Miseq
```{r}
miseq_path <- "/home/rstudio/MiSeq_SOP"
list.files(miseq_path)
```
#par ordre alphabétique
```{r}
fnFs <- sort(list.files(miseq_path, pattern="_R1_001.fastq"))
fnRs <- sort(list.files(miseq_path, pattern="_R2_001.fastq"))
#extraire un échantillon
sampleNames <- sapply(strsplit(fnFs, "_"), `[`, 1)
fnFs <- file.path(miseq_path, fnFs)
fnRs <- file.path(miseq_path, fnRs)
fnRs[1:3]
```
```{r}
plotQualityProfile(fnFs[1:2])
```
```{r}
filt_path <- file.path(miseq_path, "filtered") # Place filtered files in filtered/ subdirectory
if(!file_test("-d", filt_path)) dir.create(filt_path)
filtFs <- file.path(filt_path, paste0(sampleNames, "_F_filt.fastq.gz"))
filtRs <- file.path(filt_path, paste0(sampleNames, "_R_filt.fastq.gz"))
```

```{r}
out <- filterAndTrim(fnFs, filtFs, fnRs, filtRs, truncLen=c(240,160),
              maxN=0, maxEE=c(2,2), truncQ=2, rm.phix=TRUE,
              compress=TRUE, multithread=TRUE)
head(out)
```

```{r}
derepFs <- derepFastq(filtFs, verbose=TRUE)
derepRs <- derepFastq(filtRs, verbose=TRUE)
# Name the derep-class objects by the sample names
names(derepFs) <- sampleNames
names(derepRs) <- sampleNames
```

```{r}
errF <- learnErrors(filtFs, multithread=TRUE)
errR <- learnErrors(filtRs, multithread=TRUE)
```
```{r}
plotErrors(errF)
plotErrors(errR)

```

```{r}
dadaFs <- dada(derepFs, err=errF, multithread=TRUE)
```
```{r}
dadaRs <- dada(derepRs, err=errR, multithread=TRUE)
```
```{r}
dadaFs[[1]]
```
```{r}
mergers <- mergePairs(dadaFs, derepFs, dadaRs, derepRs)
```

```{r}
seqtabAll <- makeSequenceTable(mergers[!grepl("Mock", names(mergers))])
table(nchar(getSequences(seqtabAll)))
```
```{r}
seqtabNoC <- removeBimeraDenovo(seqtabAll)
```

```{bash}
```


```{bash}
cd ~
wget https://zenodo.org/record/4310151/files/rdp_train_set_18.fa.gz
```

```{r}
fastaRef <- "/home/rstudio/rdp_train_set_18.fa.gz"
taxTab <- assignTaxonomy(seqtabNoC, refFasta = fastaRef, multithread=TRUE)
unname(head(taxTab))
```
```{r}
seqs <- getSequences(seqtabNoC)
names(seqs) <- seqs # This propagates to the tip labels of the tree
alignment <- AlignSeqs(DNAStringSet(seqs), anchor=NA,verbose=FALSE)
```

```{r}
phangAlign <- phyDat(as(alignment, "matrix"), type="DNA")
dm <- dist.ml(phangAlign)
treeNJ <- NJ(dm) # Note, tip order != sequence order
fit = pml(treeNJ, data=phangAlign)
fitGTR <- update(fit, k=4, inv=0.2)
fitGTR <- optim.pml(fitGTR, model="GTR", optInv=TRUE, optGamma=TRUE,
        rearrangement = "stochastic", control = pml.control(trace = 0))
detach("package:phangorn", unload=TRUE)
```

```{r}
samdf <- read.csv("https://raw.githubusercontent.com/spholmes/F1000_workflow/master/data/MIMARKS_Data_combined.csv",header=TRUE)
```

```{r}
samdf$SampleID <- paste0(gsub("00", "", samdf$host_subject_id), "D", samdf$age-21)
```

```{r}
samdf <- samdf[!duplicated(samdf$SampleID),]
rownames(seqtabAll) <- gsub("124", "125", rownames(seqtabAll))#corriger l'ecart
```


```{r}
all(rownames(seqtabAll) %in% samdf$SampleID)
```

```{r}
rownames(samdf) <- samdf$SampleID
keep.cols <- c("collection_date", "biome", "target_gene", "target_subfragment",
"host_common_name", "host_subject_id", "age", "sex", "body_product", "tot_mass",
"diet", "family_relationship", "genotype", "SampleID") 
samdf <- samdf[rownames(seqtabAll), keep.cols]
```

```{r}
ps <- phyloseq(otu_table(seqtabNoC, taxa_are_rows=FALSE), 
               sample_data(samdf), 
               tax_table(taxTab),phy_tree(fitGTR$tree))
ps <- prune_samples(sample_names(ps) != "Mock", ps) # Remove mock sample
ps
```
```{r}
ps_connect <-url("https://raw.githubusercontent.com/spholmes/F1000_workflow/master/data/ps.rds")
ps = readRDS(ps_connect)
ps
```
```{r}
rank_names(ps)#affiche les classements disponible sur les donnees
```
```{r}
table(tax_table(ps)[, "Phylum"], exclude = NULL)## Creer un tableau, nombre de fonctionnalites pour chaque phyla
```
```{r}
ps <- subset_taxa(ps, !is.na(Phylum) & !Phylum %in% c("", "uncharacterized"))#les entites avec des annotations de phylum ambigues sont egalement supprimees
```

```{r}
prevdf = apply(X = otu_table(ps),
               MARGIN = ifelse(taxa_are_rows(ps), yes = 1, no = 2),
               FUN = function(x){sum(x > 0)})
## Calculer la prévalence de chaque fonctionnalité, stocker en tant que data.frame
```
## Ajouter la taxonomie et le nombre total de lectures à ce data.frame
```{r}
prevdf = data.frame(Prevalence = prevdf,
                    TotalAbundance = taxa_sums(ps),
                    tax_table(ps))
```
#Existe-t-il des embranchements composés principalement de caractéristiques à faible prévalence ? Calculez les prévalences totales et moyennes des caractéristiques dans chaque phylum.
```{r}
plyr::ddply(prevdf, "Phylum", function(df1){cbind(mean(df1$Prevalence),sum(df1$Prevalence))})
```
#Deinococcus-Thermus est apparu dans un peu plus d'un pour cent des échantillons et Fusobacteria est apparu dans seulement 2 échantillons au total. Dans certains cas, il pourrait être intéressant d'explorer ces deux phylums plus en détail malgré cela (mais probablement pas les deux échantillons de Fusobacteria). Pour les besoins de cet exemple, cependant, ils seront filtrés de l'ensemble de données.
#
# Définir les phylums à filtrer
```{r}
filterPhyla = c("Fusobacteria", "Deinococcus-Thermus")
```
## Filtrer les entrées avec Phylum non identifié.
```{r}
ps1 = subset_taxa(ps, !Phylum %in% filterPhyla)
ps1
```
## Sous-ensemble des phylums restants
```{r}
## Inclure une supposition pour le paramètre
prevdf1 = subset(prevdf, Phylum %in% get_taxa_unique(ps1, "Phylum"))
ggplot(prevdf1, aes(TotalAbundance, Prevalence / nsamples(ps),color=Phylum)) +geom_hline(yintercept = 0.05, alpha = 0.5, linetype = 2) +  geom_point(size = 2, alpha = 0.7) +
  scale_x_log10() +  xlab("Total Abundance") + ylab("Prevalence [Frac. Samples]") +
  facet_wrap(~Phylum) + theme(legend.position="none")

```
## Définir le seuil de prévalence à 5 % du total des échantillons
```{r}
prevalenceThreshold = 0.05 * nsamples(ps)
prevalenceThreshold
```
## Exécuter le filtre de prévalence, en utilisant la fonction `prune_taxa()`
```{r}
keepTaxa = rownames(prevdf1)[(prevdf1$Prevalence >= prevalenceThreshold)]
ps2 = prune_taxa(keepTaxa, ps)
```

## Combien de genres seraient présents après filtrage ?
```{r}
length(get_taxa_unique(ps2, taxonomic.rank = "Genus"))
```
```{r}
ps3 = tax_glom(ps2, "Genus", NArm = TRUE)
```

```{r}
h1 = 0.4
ps4 = tip_glom(ps2, h = h1)
```
#la fonction de phyloseq plot_tree()compare les données originales non filtrées, l'arbre après agglomération taxonoïque et l'arbre après agglomération phylogénétique. Ceux-ci sont stockés en tant qu'objets de tracé distincts, puis rendus ensemble dans un graphique combiné à l'aide de gridExtra::grid.arrange.
```{r}
multiPlotTitleTextSize = 15
p2tree = plot_tree(ps2, method = "treeonly",
                   ladderize = "left",
                   title = "Before Agglomeration") +
  theme(plot.title = element_text(size = multiPlotTitleTextSize))
p3tree = plot_tree(ps3, method = "treeonly",
                   ladderize = "left", title = "By Genus") +
  theme(plot.title = element_text(size = multiPlotTitleTextSize))
p4tree = plot_tree(ps4, method = "treeonly",
                   ladderize = "left", title = "By Height") +
  theme(plot.title = element_text(size = multiPlotTitleTextSize))
```

```{r}
grid.arrange(nrow = 1, p2tree, p3tree, p4tree)
```
#le 1er arbre avant agglomération (toutes les séquences)
#2ème arbre les séquences qui ont le mm genre
#3ème arbre regroupement par distance(regroupement dse séquences qui sont à une distance moins de 0.4 en une seule branche) 

#prévalence= nbr d'echan dans quelle apparaisse ces taxa

#Taxons agglomérés= regrouper ensemple ce qui ont la mm taxonomie(opptionnel)
#Transformation de la valeur d'abondance= normalisation 
```{r}
plot_abundance = function(physeq,title = "",
                          Facet = "Order", Color = "Phylum"){
  p1f = subset_taxa(physeq, Phylum %in% c("Firmicutes"))
  mphyseq = psmelt(p1f)
  mphyseq <- subset(mphyseq, Abundance > 0)
  ggplot(data = mphyseq, mapping = aes_string(x = "sex",y = "Abundance",
                              color = Color, fill = Color)) +
    geom_violin(fill = NA) +
    geom_point(size = 1, alpha = 0.3,
               position = position_jitter(width = 0.3)) +
    facet_wrap(facets = Facet) + scale_y_log10()+
    theme(legend.position="none")
}
```

```{r}
ps3ra = transform_sample_counts(ps3, function(x){x / sum(x)})
```

```{r}
plotBefore = plot_abundance(ps3,"")
plotAfter = plot_abundance(ps3ra,"")
# Combine each plot into one graphic.
grid.arrange(nrow = 2,  plotBefore, plotAfter)
```
#Sous-ensemble par taxonomie
```{r}
psOrd = subset_taxa(ps3ra, Order == "Lactobacillales")
plot_abundance(psOrd, Facet = "Genus", Color = NULL)
```
```{r}
library(shiny)
library(miniUI)
#library(caret)
library(pls) 
library(e1071) 
library(ggplot2)
library(randomForest)
library(dplyr)
library(ggrepel)
library(nlme)
library(devtools)
library(reshape2)
library(PMA)
#library(structSSI)
library(ade4)
library(ggnetwork)
library(intergraph)
library(scales)
#library(jfukuyama/phyloseqGraphTest)
library(genefilter)
library(impute)
```

```{r}
qplot(sample_data(ps)$age, geom = "histogram",binwidth=20) + xlab("age")
```
```{r}
qplot(log10(rowSums(otu_table(ps))),binwidth=0.2) +
  xlab("Logged counts-per-sample")
```
```{r}
sample_data(ps)$age_binned <- cut(sample_data(ps)$age,
                          breaks = c(0, 100, 200, 400))
levels(sample_data(ps)$age_binned) <- list(Young100="(0,100]", Mid100to200="(100,200]", Old200="(200,400]")
sample_data(ps)$family_relationship=gsub(" ","",sample_data(ps)$family_relationship)
pslog <- transform_sample_counts(ps, function(x) log(1 + x))
out.wuf.log <- ordinate(pslog, method = "MDS", distance = "wunifrac")
evals <- out.wuf.log$values$Eigenvalues
plot_ordination(pslog, out.wuf.log, color = "age_binned") +
  labs(col = "Binned Age") +
  coord_fixed(sqrt(evals[2] / evals[1]))
```
```{r}
outliers <- c("F5D165", "F6D165", "M3D175", "M4D175", "M5D175", "M6D175")
ps <- prune_samples(!(sample_names(ps) %in% outliers), ps)
```

```{r}
which(!rowSums(otu_table(ps)) > 1000)
#supprimer les échantillons avec moins de 1 000 lectures
```
```{r}
ps <- prune_samples(rowSums(otu_table(ps)) > 1000, ps)
pslog <- transform_sample_counts(ps, function(x) log(1 + x))
```

```{r}
out.pcoa.log <- ordinate(pslog,  method = "MDS", distance = "bray")
evals <- out.pcoa.log$values[,1]
plot_ordination(pslog, out.pcoa.log, color = "age_binned",
                  shape = "family_relationship") +
  labs(col = "Binned Age", shape = "Litter")+
  coord_fixed(sqrt(evals[2] / evals[1]))
```
```{r}
out.dpcoa.log <- ordinate(pslog, method = "DPCoA")
evals <- out.dpcoa.log$eig
plot_ordination(pslog, out.dpcoa.log, color = "age_binned", label= "SampleID",
                  shape = "family_relationship") +
  labs(col = "Binned Age", shape = "Litter")+
  coord_fixed(sqrt(evals[2] / evals[1]))

```
```{r}
plot_ordination(pslog, out.dpcoa.log, type = "species", color = "Phylum") +
  coord_fixed(sqrt(evals[2] / evals[1]))
```
```{r}
out.wuf.log <- ordinate(pslog, method = "PCoA", distance ="wunifrac")
evals <- out.wuf.log$values$Eigenvalues
plot_ordination(pslog, out.wuf.log, color = "age_binned",
                  shape = "family_relationship") +
  coord_fixed(sqrt(evals[2] / evals[1])) +
  labs(col = "Binned Age", shape = "Litter")
```
...
